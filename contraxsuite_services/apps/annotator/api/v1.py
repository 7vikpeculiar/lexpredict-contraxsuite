"""
    Copyright (C) 2017, ContraxSuite, LLC

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    You can also be released from the requirements of the license by purchasing
    a commercial license from ContraxSuite, LLC. Buying such a license is
    mandatory as soon as you develop commercial activities involving ContraxSuite
    software without disclosing the source code of your own applications.  These
    activities include: offering paid services to customers as an ASP or "cloud"
    provider, processing documents on the fly in a web application,
    or shipping ContraxSuite within a closed source product.
"""
# -*- coding: utf-8 -*-

from typing import Dict, List, Union
import traceback

from django.conf.urls import url
from django.db import transaction
from rest_framework import views
from rest_framework.response import Response

from apps.document.field_types import FIELD_TYPES_REGISTRY
from apps.document.models import Document, DocumentField, DocumentFieldValue, TextUnit, DocumentTypeField

__author__ = "ContraxSuite, LLC; LexPredict, LLC"
__copyright__ = "Copyright 2015-2018, ContraxSuite, LLC"
__license__ = "https://github.com/LexPredict/lexpredict-contraxsuite/blob/1.1.4/LICENSE"
__version__ = "1.1.4"
__maintainer__ = "LexPredict, LLC"
__email__ = "support@contraxsuite.com"


def _to_dto(field_value: DocumentFieldValue, **kwargs):
    res = {
        'id': field_value.pk,
        'document_id': field_value.document_id,
        'user_id': field_value.modified_by_id or field_value.created_by_id,
        'value': field_value.value,
        'field_id': field_value.field_id
    }
    if field_value.location_start is not None and field_value.location_end is not None:
        res['ranges'] = [{
            'start': '',
            'end': '',
            'startOffset': field_value.location_start,
            'endOffset': field_value.location_end
        }]
        res['quote'] = field_value.location_text
        res['text'] = None

    if kwargs:
        res.update(kwargs)

    return res


def _format_error(exc):
    return repr(exc)


class AnnotatorError(RuntimeError):
    pass


class DocumentAnnotationSuggestFieldValueView(views.APIView):
    def post(self, request, *args, **kwargs):
        """
        Suggest field value before creating an annotation.
        Accepts the same JSON structure as annotation saving endpoint.
        Returns suggested field value of the specified field possibly found in the provided text.

        """
        annotator_data = request.data
        doc = Document.objects.get(pk=annotator_data['document_id'])
        document_field = DocumentField.objects.get(pk=annotator_data.get('field_id'))
        location_text = annotator_data['quote']

        field_type = FIELD_TYPES_REGISTRY.get(document_field.type)

        field_value = field_type.suggest_value(doc, document_field, location_text)

        return Response({'suggested_value': field_value})


class DocumentAnnotationStorageSearchView(views.APIView):
    def get(self, request, *args, **kwargs):
        """
        Get all annotations made for the specified document and field.
        GET params:
          - document_id: int PK of the document.
        Returns annotations in JSON acceptable by annotator.js.
        """
        document_id = request.GET.get('document_id')

        field_values = DocumentFieldValue.objects.filter(document_id=document_id, removed_by_user=False)

        return Response({'rows': [_to_dto(a) for a in field_values]})


def _save_annotation(annotator_data: Dict, user, cache_document=True) -> Dict:
    """
    Add a new annotation / document field value.
    Accepts JSON structure generated by annotator.js.
    """
    doc = Document.objects.get(pk=annotator_data['document_id'])
    document_field = DocumentField.objects.get(pk=annotator_data.get('field_id'))  # type: DocumentField

    if document_field.is_calculated():
        raise AnnotatorError('Cannot save annotation. '
                             'This field should be calculated form other fields.')

    value = annotator_data.get('value')
    selection_range = annotator_data['ranges'][0] if 'ranges' in annotator_data else None

    if document_field.requires_text_annotations:
        if not selection_range:
            raise AnnotatorError(
                'Field {0} requires text annotation but no text ranges provided'.format(document_field))
        location_start = selection_range['startOffset']
        location_end = selection_range['endOffset']
        location_text = doc.full_text[location_start:location_end]
        sentence_text_unit = TextUnit.objects.filter(document=doc,
                                                     unit_type='sentence',
                                                     location_start__lte=location_end,
                                                     location_end__gte=location_start).first()
    else:
        location_start = None
        location_end = None
        location_text = None
        sentence_text_unit = None

    field_type = FIELD_TYPES_REGISTRY.get(document_field.type)
    field_value = field_type.save_value(doc,
                                        document_field,
                                        location_start,
                                        location_end,
                                        location_text,
                                        sentence_text_unit,
                                        value,
                                        user,
                                        False,
                                        True)

    calculated_fields_errors = None
    if cache_document:
        _, calculated_fields_errors = doc.cache_field_values()

    return _to_dto(field_value, calculated_fields_errors=calculated_fields_errors)


def _delete_annotation(pk, cache_document=True):
    field_value = DocumentFieldValue.objects.get(pk=pk)
    doc = field_value.document
    field = field_value.field
    field_type = FIELD_TYPES_REGISTRY.get(field.type)

    calculate_fields_errors = None
    with transaction.atomic():
        if field_value.created_by_id is not None:
            field_type.delete(field_value)
        else:
            field_type.mark_removed_by_user(field_value)

        DocumentTypeField.objects.set_dirty_for_value(field_value)
        if cache_document:
            _, calculate_fields_errors = doc.cache_field_values()
    return _to_dto(field_value, calculate_fields_errors=calculate_fields_errors)


class DocumentAnnotationsView(views.APIView):
    def post(self, request, *args, **kwargs):
        try:
            return Response(_save_annotation(request.data, request.user))
        except Exception as e:
            return Response({'message': _format_error(e)}, status=500)


class DocumentAnnotationsBatchAPIView(views.APIView):
    def put(self, request, *args, **kwargs):
        batch_commands = request.data  # type: List

        res = []
        document_ids_to_cache = dict()
        for cmd_num, cmd in enumerate(batch_commands):
            operation_uid = cmd.get('operation_uid')
            try:
                action = cmd['action']

                if action == 'delete':
                    pk = cmd['id']
                    deleted_field_value = _delete_annotation(pk, False)
                    document_ids_to_cache[deleted_field_value.get('document_id')] = cmd_num
                    res.append({'operation_uid': operation_uid, 'status': 'success', 'data': deleted_field_value})
                elif action == 'save':
                    data = cmd['data']
                    saved_field_value = _save_annotation(data, request.user, False)
                    document_ids_to_cache[saved_field_value.get('document_id')] = cmd_num
                    res.append({'operation_uid': operation_uid, 'status': 'success', 'data': saved_field_value})
            except Exception as e:
                res.append({'operation_uid': operation_uid, 'status': 'error', 'message': _format_error(e)})
        for doc_id, cmd_num in document_ids_to_cache.items():
            if doc_id:
                try:
                    doc = Document.objects.get(pk=doc_id)
                    _, calculated_fields_errors = doc.cache_field_values()
                    res[cmd_num]['data']['calculated_fields_errors'] = calculated_fields_errors
                except Document.DoesNotExist:
                    pass

        return Response(res)


class DocumentAnnotationView(views.APIView):
    def get(self, request, pk, *args):
        return Response(_to_dto(DocumentFieldValue.objects.get(pk=pk)))

    def post(self, request, *args, **kwargs):
        return Response(_save_annotation(request.data, request.user))

    def put(self, request, pk, *args):
        """
        Update an existing annotation. Accepts JSON structure generated by annotator.js.
        """
        return Response(_save_annotation(request.data, request.user, pk))

    def delete(self, request, pk, *args):
        """
        Delete an annotation.
        """
        return Response(_delete_annotation(pk))


urlpatterns = [
    url(
        r'^search$',
        DocumentAnnotationStorageSearchView.as_view(),
        name='annotations_search'
    ),

    url(
        r'^suggest$',
        DocumentAnnotationSuggestFieldValueView.as_view(),
        name='annotations_suggest'
    ),

    url(
        r'^annotations/?$',
        DocumentAnnotationsView.as_view(),
        name='annotations'
    ),
    url(
        r'^batch/?$',
        DocumentAnnotationsBatchAPIView.as_view(),
        name='batch'
    ),
    url(
        r'^annotations/(?P<pk>\d+)$',
        DocumentAnnotationView.as_view(),
        name='annotation'
    ),
]
